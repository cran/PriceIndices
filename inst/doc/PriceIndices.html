<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>PriceIndices</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">PriceIndices</h1>



<div id="priceindices-a-package-for-bilateral-and-multilateral-price-index-calculations" class="section level1">
<h1>PriceIndices – a Package for Bilateral and Multilateral Price Index
Calculations</h1>
<p><strong>author: Jacek Białek, University of Lodz, Statistics
Poland</strong> <!-- badges: start --> <!-- badges: end --></p>
<p>Goals of PriceIndices are as follows: a) data processing before price
index calculations; b) bilateral and multilateral price index
calculations; c) extending multilateral price indices. You can download
the package documentation from <a href="https://github.com/JacekBialek/important_documents/blob/main/PriceIndices_manual.pdf">here</a>.
Too read more about the package please see (and cite :)) papers:</p>
<p>Białek, J. (2021). PriceIndices – a New R Package for Bilateral and
Multilateral Price Index Calculations, Statistika – Statistics and
Economy Journal, Vol. 2/2021, 122-141, Czech Statistical Office,
Praga.</p>
<p>Białek, J. (2022). Scanner data processing in a newest version of the
PriceIndices package, Statistical Journal of the IAOS, 38 (4),
1369-1397, DOI: 10.3233/SJI-220963.</p>
<p>Białek, J. (2023). Scanner data processing and price index
calculations in the PriceIndices R package, Slovak Statistics and
Demography, 3, 7-20, ISNN: 1210-1095.</p>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p>You can install the released version of <strong>PriceIndices</strong>
from CRAN with:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&quot;PriceIndices&quot;</span>)</span></code></pre></div>
<p>You can install the development version of
<strong>PriceIndices</strong> from <a href="https://github.com/">GitHub</a> with:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(<span class="st">&quot;remotes&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>remotes<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">&quot;JacekBialek/PriceIndices&quot;</span>)</span></code></pre></div>
</div>
<div id="the-functionality-of-this-package-can-be-categorized-as-follows" class="section level2">
<h2>The functionality of this package can be categorized as
follows:</h2>
<ol style="list-style-type: decimal">
<li><a href="#ad1">Data sets included in the package and generating
artificial scanner data sets</a></li>
<li><a href="#ad2">Functions for data processing</a></li>
<li><a href="#ad3">Functions providing dataset characteristics</a></li>
<li><a href="#ad4">Functions for bilateral unweighted price index
calculations</a></li>
<li><a href="#ad5">Functions for bilateral weighted price index
calculations</a></li>
<li><a href="#ad6">Functions for chain price index calculations</a></li>
<li><a href="#ad7">Functions for multilateral price index
calculations</a></li>
<li><a href="#ad8">Functions for extending multilateral price indices by
using splicing methods</a></li>
<li><a href="#ad9">Functions for extending multilateral price indices by
using the FBEW method</a></li>
<li><a href="#ad10">Functions for extending multilateral price indices
by using the FBMW method</a></li>
<li><a href="#ad11">General functions for price index
calculations</a></li>
<li><a href="#ad12">Functions for comparisons of price indices</a></li>
<li><a href="#ad13">Functions for price and quantity indicator
calculations</a></li>
</ol>
<p><a id="ad1"> </a></p>
<div id="data-sets-included-in-the-package-and-generating-artificial-scanner-data-sets" class="section level3">
<h3>Data sets included in the package and generating artificial scanner
data sets</h3>
<p><strong>This package includes nine data sets: artificial and
real.</strong></p>
<p><strong><em>1) dataAGGR</em></strong></p>
<p>The first one, <strong>dataAGGR</strong>, can be used to demonstrate
the <strong>data_aggregating</strong> function. This is a collection of
artificial scanner data on milk products sold in three different months
and it contains the following columns: <strong>time</strong> - dates of
transactions (Year-Month-Day: 4 different dates);
<strong>prices</strong> - prices of sold products (PLN);
<strong>quantities</strong> - quantities of sold products (liters);
<em>prodID</em> - unique product codes (3 different prodIDs);
<strong>retID</strong> - unique codes identifying outlets/retailer sale
points (4 different retIDs); <strong>description</strong> - descriptions
of sold products (two subgroups: goat milk, powdered milk).</p>
<p><strong><em>2) dataMATCH</em></strong></p>
<p>The second one, <strong>dataMATCH</strong>, can be used to
demonstrate the <strong>data_matching</strong> function and it will be
described in the next part of the guidelines. Generally, this artificial
data set contains the following columns: <strong>time</strong> - dates
of transactions (Year-Month-Day); <strong>prices</strong> - prices of
sold products; <strong>quantities</strong> - quantities of sold
products; <strong>codeIN</strong> - internal product codes from the
retailer; <strong>codeOUT</strong> - external product codes, e.g. GTIN
or SKU in the real case; <strong>description</strong> - descriptions of
sold products, eg. ‘product A’, ‘product B’, etc.</p>
<p><strong><em>3) dataCOICOP</em></strong></p>
<p>The third one, <strong>dataCOICOP</strong>, is a ollection of real
scanner data on the sale of milk products sold in a period: Dec, 2020 -
Feb, 2022. It is a data frame with 10 columns and 139600 rows. The used
variables are as follows: <strong>time</strong> - dates of transactions
(Year-Month-Day); <strong>prices</strong> - prices of sold products
(PLN); <strong>quantities</strong> - quantities of sold products;
<strong>description</strong> - descriptions of sold products (original:
in Polish); <strong>codeID</strong> - retailer product codes;
<strong>retID</strong> - IDs of retailer outlets;
<strong>grammage</strong> - product grammages; <strong>unit</strong> -
sales units, e.g. ‘kg’, ‘ml’, etc.; <strong>category</strong> - product
categories (in English) corresponding to COICOP 6 levels;
<strong>coicop6</strong> - identifiers of local COICOP 6 groups (6
levels). Please note that this data set can serve as a training or
testing set in product classification using machine learning methods
(see the functions: <strong>model_classification</strong> and
<strong>data_classifying</strong>).</p>
<p><strong><em>4) data_DOWN_UP_SIZED</em></strong></p>
<p>This data set, <strong>data_DOWN_UP_SIZED</strong>, is a collection
of scanner data on the sale of coffee in the period from January 2024 to
February 2024 and it contains downsized products (see the
<strong>shrinkflation</strong> function). It is a data frame with 6
columns and 51 rows. The used variables are as follows:
<strong>time</strong> - dates of transactions (Year-Month-Day),
<strong>prices</strong> - prices of sold products [PLN],
<strong>quantities</strong> - quantities of sold products (in units
resulting the product description), <strong>codeIN</strong> - unique
internal product codes (retaler product codes), <strong>codeOUT</strong>
- unique external product codes (e.g. GTIN, EAN, SKU),
<strong>description</strong> - descriptions of sold coffee products.</p>
<p><strong><em>5) milk</em></strong></p>
<p>This data set, <strong>milk</strong>, is a collection of scaner data
on the sale of milk in one of Polish supermarkets in the period from
December 2018 to August 2020. It is a data frame with 6 columns and 4386
rows. The used variables are as follows: <strong>time</strong> - dates
of transactions (Year-Month-Day); <strong>prices</strong> - prices of
sold products (PLN); <strong>quantities</strong> - quantities of sold
products (liters); <strong>prodID</strong> - unique product codes
obtained after product matching (data set contains 68 different
prodIDs); <strong>retID</strong> - unique codes identifying
outlets/retailer sale points (data set contains 5 different retIDs);
<strong>description</strong> - descriptions of sold milk products (data
set contains 6 different product descriptions corresponding to
<em>subgroups</em> of the milk group).</p>
<p><strong><em>6) coffee</em></strong></p>
<p>This data set, <strong>coffee</strong>, is a collection of scanner
data on the sale of coffee in one of Polish supermarkets in the period
from December 2017 to October 2020. It is a data frame with 6 columns
and 42561 rows. The used variables are as follows: <strong>time</strong>
- dates of transactions (Year-Month-Day); <strong>prices</strong> -
prices of sold products (PLN); <strong>quantities</strong> - quantities
of sold products (kg); <strong>prodID</strong> - unique product codes
obtained after product matching (data set contains 79 different
prodIDs); <strong>retID</strong> - unique codes identifying
outlets/retailer sale points (data set contains 20 different retIDs);
<strong>description</strong> - descriptions of sold coffee products
(data set contains 3 different product descriptions corresponding to
<em>subgroups</em> of the coffee group).</p>
<p><strong><em>7) sugar</em></strong></p>
<p>This data set, <strong>sugar</strong>, is a collection of scanner
data on the sale of coffee in one of Polish supermarkets in the period
from December 2017 to October 2020. It is a data frame with 6 columns
and 7666 rows. The used variables are as follows: <strong>time</strong>
- dates of transactions (Year-Month-Day); <strong>prices</strong> -
prices of sold products (PLN); <strong>quantities</strong> - quantities
of sold products (kg); <strong>prodID</strong> - unique product codes
obtained after product matching (data set contains 11 different
prodIDs); <strong>retID</strong> - unique codes identifying
outlets/retailer sale points (data set contains 20 different retIDs);
<strong>description</strong> - descriptions of sold sugar products (data
set contains 3 different product descriptions corresponding to
<em>subgroups</em> of the sugar group).</p>
<p><strong><em>8) dataU</em></strong></p>
<p>This data set, <strong>dataU</strong>, is a collection of artificial
scanner data on 6 products sold in Dec, 2018. Product descriptions
contain the information about their grammage and unit. It is a data
frame with 5 columns and 6 rows. The used variables are as follows:
<strong>time</strong> - dates of transactions (Year-Month-Day);
<strong>prices</strong> - prices of sold products (PLN);
<strong>quantities</strong> - quantities of sold products (item);
<strong>prodID</strong> - unique product codes;
<strong>description</strong> - descriptions of sold products (data set
contains 6 different product descriptions).</p>
<p><strong><em>9) dataMARS</em></strong></p>
<p>This data set, <strong>dataMARS</strong>, is a collection of
artificial scanner data on shirts for testing the MARS method. It
contains 9 columns and 44 rows. The used variables are as follows:
<strong>time</strong> - dates of transactions (Year-Month-Day),
<strong>prices</strong> - prices of sold products [PLN],
<strong>quantities</strong> - quantities of sold products,
<strong>prodID</strong> - unique product identifiers (data set contains
28 different prodIDs), <strong>description</strong> - descriptions
(labels) of sold shirts (data set contains 12 different descriptions),
<strong>brand</strong> - brand of sold shirts (data set contains 2
different brands: X and Y), <strong>gender</strong> - gender of the
person for whom the shirt is dedicated (M or F), <strong>size</strong> -
size of shirts (M, L, and XL), <strong>fabric</strong> - fabric of
shirts (cotton, polyester, blend).</p>
<p>The set <strong>milk</strong> represents a typical data frame used in
the package for most calculations and is organized as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">library</span>(PriceIndices)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="fu">head</span>(milk)</span></code></pre></div>
<p>Available subgroups of sold milk are</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">unique</span>(milk<span class="sc">$</span>description)</span></code></pre></div>
<p><strong>Generating artificial scanner data sets in the
package</strong></p>
<p>The package includes the <strong>generate</strong> function which
provides an artificial scanner data sets where prices and quantities are
lognormally distributed. The characteristics for these lognormal
distributions are set by <strong>pmi</strong>, <strong>sigma</strong>,
<strong>qmi</strong> and <strong>qsigma</strong> parameters. This
function works for the fixed number of products and outlets (see
<strong>n</strong> and <strong>r</strong> parameters). The generated
data set is ready for further price index calculations. For
instance:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>dataset<span class="ot">&lt;-</span><span class="fu">generate</span>(<span class="at">pmi=</span><span class="fu">c</span>(<span class="fl">1.02</span>,<span class="fl">1.03</span>,<span class="fl">1.04</span>),<span class="at">psigma=</span><span class="fu">c</span>(<span class="fl">0.05</span>,<span class="fl">0.09</span>,<span class="fl">0.02</span>),</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>                  <span class="at">qmi=</span><span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">4</span>),<span class="at">qsigma=</span><span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">0.1</span>,<span class="fl">0.15</span>),</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>                  <span class="at">start=</span><span class="st">&quot;2020-01&quot;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="fu">head</span>(dataset)</span></code></pre></div>
<p>From the other hand you can use <strong>tindex</strong> function to
obtain the theoretical value of the unweighted price index for
lognormally distributed prices (the month defined by
<strong>start</strong> parameter plays a role of the fixed base period).
The characteristics for these lognormal distributions are set by
<strong>pmi</strong> and <strong>sigma</strong> parameters. The
<strong>ratio</strong> parameter is a logical parameter indicating how
we define the theoretical unweighted price index. If it is set to TRUE
then the resulting value is a ratio of expected price values from
compared months; otherwise the resulting value is the expected value of
the ratio of prices from compared months.The function provides a data
frame consisting of dates and corresponding expected values of the
theoretical unweighted price index. For example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">tindex</span>(<span class="at">pmi=</span><span class="fu">c</span>(<span class="fl">1.02</span>,<span class="fl">1.03</span>,<span class="fl">1.04</span>),<span class="at">psigma=</span><span class="fu">c</span>(<span class="fl">0.05</span>,<span class="fl">0.09</span>,<span class="fl">0.02</span>),<span class="at">start=</span><span class="st">&quot;2020-01&quot;</span>,<span class="at">ratio=</span><span class="cn">FALSE</span>)</span></code></pre></div>
<p>The User may also generate an artificial scanner dataset where prices
are lognormally distributed and quantities are calculated under the
assumption that consumers have CES (Constant Elasticity of Substitution)
preferences and their spending on all products is fixed (see the
<strong>generate_CES</strong> function). Please watch the following
example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co">#Generating an artificial dataset (the elasticity of substitution is 1.25)</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">generate_CES</span>(<span class="at">pmi=</span><span class="fu">c</span>(<span class="fl">1.02</span>,<span class="fl">1.03</span>),<span class="at">psigma=</span><span class="fu">c</span>(<span class="fl">0.04</span>,<span class="fl">0.03</span>),</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="at">elasticity=</span><span class="fl">1.25</span>,<span class="at">start=</span><span class="st">&quot;2020-01&quot;</span>,<span class="at">n=</span><span class="dv">100</span>,<span class="at">days=</span><span class="cn">TRUE</span>)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="fu">head</span>(df)</span></code></pre></div>
<p>Now, we can verify the value of elasticity of substitution using this
generated dataset:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co">#Verifying the elasticity of substitution</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="fu">elasticity</span>(df, <span class="at">start=</span><span class="st">&quot;2020-01&quot;</span>,<span class="at">end=</span><span class="st">&quot;2020-02&quot;</span>)</span></code></pre></div>
<p><a id="ad2"> </a></p>
</div>
<div id="functions-for-data-processing" class="section level3">
<h3>Functions for data processing</h3>
<p><strong>data_preparing</strong></p>
<p>This function returns a prepared data frame based on the user’s data
set (you can check if your data set it is suitable for further price
index calculation by using <strong>data_check</strong> function). The
resulting data frame is ready for further data processing (such as data
selecting, matching or filtering) and it is also ready for price index
calculations (if only it contains the required columns). The resulting
data frame is free from missing values, negative and (optionally) zero
prices and quantities. As a result, the column <strong>time</strong> is
set to be <strong>Date</strong> type (in format: ‘Year-Month-01’), while
the columns <strong>prices</strong> and <strong>quantities</strong> are
set to be <strong>numeric</strong>. If the <strong>description</strong>
parameter is set to <em>TRUE</em> then the column
<strong>description</strong> is set to be <strong>character</strong>
type (otherwise it is deleted). Please note that the
<strong>milk</strong> set is an already prepared dataset but let us
assume for a moment that we want to make sure that it does not contain
missing values and we do not need the column
<strong>description</strong> for further calculations. For this purpose,
we use the <strong>data_preparing</strong> function as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">data_preparing</span>(milk, <span class="at">time=</span><span class="st">&quot;time&quot;</span>,<span class="at">prices=</span><span class="st">&quot;prices&quot;</span>,<span class="at">quantities=</span><span class="st">&quot;quantities&quot;</span>))</span></code></pre></div>
<p><strong>data_imputing</strong></p>
<p>This function imputes missing prices (unit values) and (optionally)
zero prices by using one of the following methods: carry
forward/backward, overall mean, class mean (targeted mean). The
imputation can be done for each outlet separately or for aggregated data
(see the <strong>outlets</strong> parameter). For the carry
forward/backward method: if a missing product has a previous price then
that previous price is carried forward until the next real observation.
If there is no previous price then the next real observation is found
and carried backward. For the overall mean method: the procedure is
similar, except that the imputed price is based on the previously
recorded price multiplied (or divided - in the case of the next recorded
price) by the price index determined for the quoted and imputed period.
The user can select the index formula via the <strong>formula</strong>
parameter. For the class mean method (also known as targeted mean
method): the procedure is analogous to the overall mean method, but the
price index is determined for the product class specified by the
<strong>class</strong> parameter. The quantities for imputed prices are
set to zero. The function returns a data frame (monthly aggregated)
which is ready for price index calculations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co">#Creating a data frame with zero prices (df)</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>data<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">filter</span>(milk,time<span class="sc">&gt;=</span><span class="fu">as.Date</span>(<span class="st">&quot;2018-12-01&quot;</span>) <span class="sc">&amp;</span> time<span class="sc">&lt;=</span><span class="fu">as.Date</span>(<span class="st">&quot;2019-03-01&quot;</span>))</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>sample<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">sample_n</span>(data, <span class="dv">100</span>)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>rest<span class="ot">&lt;-</span><span class="fu">setdiff</span>(data, sample)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>sample<span class="sc">$</span>prices<span class="ot">&lt;-</span><span class="dv">0</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">rbind</span>(sample, rest)</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#The Fisher price index calculated for the original data set</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="fu">fisher</span>(df, <span class="st">&quot;2018-12&quot;</span>,<span class="st">&quot;2019-03&quot;</span>)</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#Zero price imputations:</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>df2<span class="ot">&lt;-</span><span class="fu">data_imputing</span>(df, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-02&quot;</span>,</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>              <span class="at">zero_prices=</span><span class="cn">TRUE</span>,</span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a>              <span class="at">outlets=</span><span class="cn">TRUE</span>)</span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="co">#The Fisher price index calculated for the data set with imputed prices:</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="fu">fisher</span>(df2, <span class="st">&quot;2018-12&quot;</span>,<span class="st">&quot;2019-03&quot;</span>)</span></code></pre></div>
<p><strong>data_aggregating</strong></p>
<p>The function aggregates the user’s data frame over time and/or over
outlets. Consequently, we obtain monthly data, where the unit value is
calculated instead of a price for each <strong>prodID</strong> observed
in each month (the time column gets the Date format: “Year-Month-01”).
If paramter <strong>join_outlets</strong> is <em>TRUE</em>, then the
function also performs aggregation over outlets (<em>retIDs</em>) and
the <strong>retID</strong> column is removed from the data frame. The
main advantage of using this function is the ability to reduce the size
of the data frame and the time needed to calculate the price index. For
instance, let us consider the following data set:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>dataAGGR</span></code></pre></div>
<p>After aggregating this data set over time and outlets we obtain:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">data_aggregating</span>(dataAGGR)</span></code></pre></div>
<p><strong>data_unit</strong></p>
<p>The function returns the user’s data frame with two additional
columns: <strong>grammage</strong> and <strong>unit</strong> (both are
character type). The values of these columns are extracted from product
descriptions on the basis of provided <strong>units</strong>. Please
note, that the function takes into consideration a sign of the
multiplication, e.g. if the product description contains: ‘2x50 g’, we
will obtain: <strong>grammage: 100</strong> and <strong>unit: g</strong>
for that product (for <strong>multiplication</strong> set to ‘x’). For
example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">data_unit</span>(dataU,<span class="at">units=</span><span class="fu">c</span>(<span class="st">&quot;g|ml|kg|l&quot;</span>),<span class="at">multiplication=</span><span class="st">&quot;x&quot;</span>)</span></code></pre></div>
<p><strong>data_norm</strong></p>
<p>The function returns the user’s data frame with two transformed
columns: <strong>grammage</strong> and <strong>unit</strong>, and two
rescaled columns: <strong>prices</strong> and
<strong>quantities</strong>. The above-mentioned transformation and
rescaling take into consideration the user <strong>rules</strong>.
Recalculated prices and quantities concern grammage units defined as the
second parameter in the given rule. For instance:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># Preparing a data set</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>data<span class="ot">&lt;-</span><span class="fu">data_unit</span>(dataU,<span class="at">units=</span><span class="fu">c</span>(<span class="st">&quot;g|ml|kg|l&quot;</span>),<span class="at">multiplication=</span><span class="st">&quot;x&quot;</span>)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="co"># Normalization of grammage units</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="fu">data_norm</span>(data, <span class="at">rules=</span><span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;ml&quot;</span>,<span class="st">&quot;l&quot;</span>,<span class="dv">1000</span>),<span class="fu">c</span>(<span class="st">&quot;g&quot;</span>,<span class="st">&quot;kg&quot;</span>,<span class="dv">1000</span>)))</span></code></pre></div>
<p><strong>data_selecting</strong></p>
<p>The function returns a subset of the user’s data set obtained by
selection based on keywords and phrases defined by parameters:
<strong>include</strong>, <strong>must</strong> and
<strong>exclude</strong> (an additional column <strong>coicop</strong>
is optional). Providing values of these parameters, please remember that
the procedure distinguishes between uppercase and lowercase letters only
when <strong>sensitivity</strong> is set to <em>TRUE</em>.</p>
<p>For instance, please use</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>subgroup1<span class="ot">&lt;-</span><span class="fu">data_selecting</span>(milk, <span class="at">include=</span><span class="fu">c</span>(<span class="st">&quot;milk&quot;</span>), <span class="at">must=</span><span class="fu">c</span>(<span class="st">&quot;UHT&quot;</span>))</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">head</span>(subgroup1)</span></code></pre></div>
<p>to obtain the subset of <strong>milk</strong> limited to <em>UHT</em>
category:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">unique</span>(subgroup1<span class="sc">$</span>description)</span></code></pre></div>
<p>You can use</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>subgroup2<span class="ot">&lt;-</span><span class="fu">data_selecting</span>(milk, <span class="at">must=</span><span class="fu">c</span>(<span class="st">&quot;milk&quot;</span>), <span class="at">exclude=</span><span class="fu">c</span>(<span class="st">&quot;past&quot;</span>,<span class="st">&quot;goat&quot;</span>))</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">head</span>(subgroup2)</span></code></pre></div>
<p>to obtain the subset of <strong>milk</strong> with products which are
not <em>pasteurized</em> and which are not <strong>goat</strong>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">unique</span>(subgroup2<span class="sc">$</span>description)</span></code></pre></div>
<p><strong>data_classifying</strong></p>
<p>This function predicts product COICOP levels (or any other defined
product levels) using the selected machine learning model (see the
<strong>model</strong> parameter). It provides the indicated data set
with an additional column, i.e. <em>class_predicted</em>. The selected
model must be built previously (see the
<strong>model_classification</strong> function) and after the training
process it can be saved on your disk (see the
<strong>save_model</strong> function) and then loaded at any time (see
the <strong>load_model</strong> function). Please note that the machine
learning process is based on the XGBoost algorithm (from the XGBoost
package) which is an implementation of gradient boosted decision trees
designed for speed and performance. For example, let us build a machine
learning model</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>my.grid<span class="ot">=</span><span class="fu">list</span>(<span class="at">eta=</span><span class="fu">c</span>(<span class="fl">0.01</span>,<span class="fl">0.02</span>,<span class="fl">0.05</span>),<span class="at">subsample=</span><span class="fu">c</span>(<span class="fl">0.5</span>,<span class="fl">0.8</span>))</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>data_train<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">filter</span>(dataCOICOP,dataCOICOP<span class="sc">$</span>time<span class="sc">&lt;=</span><span class="fu">as.Date</span>(<span class="st">&quot;2021-10-01&quot;</span>))</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>data_test<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">filter</span>(dataCOICOP,dataCOICOP<span class="sc">$</span>time<span class="sc">==</span><span class="fu">as.Date</span>(<span class="st">&quot;2021-11-01&quot;</span>))</span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>ML<span class="ot">&lt;-</span><span class="fu">model_classification</span>(data_train,</span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a>                         data_test,</span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>                         <span class="at">class=</span><span class="st">&quot;coicop6&quot;</span>,</span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>                         <span class="at">grid=</span>my.grid,</span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a>                         <span class="at">indicators=</span><span class="fu">c</span>(<span class="st">&quot;description&quot;</span>,<span class="st">&quot;codeIN&quot;</span>,<span class="st">&quot;grammage&quot;</span>),</span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a>                         <span class="at">key_words=</span><span class="fu">c</span>(<span class="st">&quot;uht&quot;</span>), </span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a>                         <span class="at">rounds=</span><span class="dv">60</span>)</span></code></pre></div>
<p>We can watch the results of the whole training process:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>ML<span class="sc">$</span>figure_training</span></code></pre></div>
<p>or we can observe the importance of the used indicators:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>ML<span class="sc">$</span>figure_importance</span></code></pre></div>
<p>Now, let us save the model on the disk. After saving the model we can
load it and use at any time:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co">#Setting a temporary directory as a working directory</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>wd<span class="ot">&lt;-</span><span class="fu">tempdir</span>()</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a><span class="fu">setwd</span>(wd)</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a><span class="co">#Saving and loading the model</span></span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="fu">save_model</span>(ML, <span class="at">dir=</span><span class="st">&quot;My_model&quot;</span>)</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>ML_fromPC<span class="ot">&lt;-</span><span class="fu">load_model</span>(<span class="st">&quot;My_model&quot;</span>)</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a><span class="co">#Prediction</span></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>data_predicted<span class="ot">&lt;-</span><span class="fu">data_classifying</span>(ML_fromPC, data_test)</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a><span class="fu">head</span>(data_predicted)</span></code></pre></div>
<p><strong>data_matching</strong></p>
<p>If you have a dataset with information about products sold but they
are not matched you can use the <strong>data_matching</strong> function.
In an optimal situation, your data frame contains the
<strong>codeIN</strong>, <strong>codeOUT</strong> and
<strong>description</strong> columns (see documentation), which in
practice will contain <em>retailer codes</em>, <em>GTIN</em> or
<em>SKU</em> codes and <em>product labels</em>, respectively. The
<strong>data_matching</strong> function returns a data set defined in
the first parameter (<em>data</em>) with an additional column
(<em>prodID</em>). Two products are treated as being matched if they
have the same prodID value. The procedure of generating the
above-mentioned additional column depends on the set of chosen columns
for matching (see documentation for details). For instance, let us
suppose you want to obtain matched products from the following,
artificial data set:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">head</span>(dataMATCH)</span></code></pre></div>
<p>Let us assume that products with two identical codes
(<strong>codeIN</strong> and <strong>codeOUT</strong>) or one of the
codes identical and an identical description are automatically matched.
Products are also matched if they have one of the codes identical and
the <em>Jaro-Winkler similarity</em> of their descriptions is bigger
than the fixed <strong>precision</strong> value (see documentation -
<em>Case 1</em>). Let us also suppose that you want to match all
products sold in the interval: December 2018 - February 2019. If you use
the <strong>data_matching</strong> function (as below), an additional
column (<strong>prodID</strong>) will be added to your data frame:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>data1<span class="ot">&lt;-</span><span class="fu">data_matching</span>(dataMATCH, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-02&quot;</span>, <span class="at">codeIN=</span><span class="cn">TRUE</span>, <span class="at">codeOUT=</span><span class="cn">TRUE</span>, <span class="at">precision=</span>.<span class="dv">98</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="fu">head</span>(data1)</span></code></pre></div>
<p>Let us now suppose you do not want to consider
<strong>codeIN</strong> while matching and that products with an
identical <strong>description</strong> are to be matched too:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>data2<span class="ot">&lt;-</span><span class="fu">data_matching</span>(dataMATCH, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-02&quot;</span>, </span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>                     <span class="at">codeIN=</span><span class="cn">FALSE</span>, <span class="at">onlydescription=</span><span class="cn">TRUE</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="fu">head</span>(data2)</span></code></pre></div>
<p>Now, having a <strong>prodID</strong> column, your datasets are ready
for further price index calculations, e.g.:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">fisher</span>(data1, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-02&quot;</span>)</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a><span class="fu">jevons</span>(data2, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-02&quot;</span>)</span></code></pre></div>
<p><strong>data_filtering</strong></p>
<p>This function returns a filtered data set, i.e. a reduced user’s data
frame with the same columns and rows limited by a criterion defined by
the <strong>filters</strong> parameter (see documentation). If the set
of filters is empty then the function returns the original data frame
(defined by the <strong>data</strong> parameter). On the other hand, if
all filters are chosen, i.e. <em>filters=c(extremeprices, dumpprices,
lowsales)</em>, then these filters work independently and a summary
result is returned. Please note that both variants of the
<em>extremeprices</em> filter can be chosen at the same time,
i.e. <em>plimits</em> and <em>pquantiles</em>, and they work also
independently. For example, let us assume we consider three filters:
<strong>filter1</strong> is to reject 1% of the lowest and 1% of the
highest price changes comparing March 2019 to December 2018,
<strong>filter2</strong> is to reject products with the price ratio
being less than 0.5 or bigger than 2 in the same time,
<strong>filter3</strong> rejects the same products as
<strong>filter2</strong> rejects and also products with relatively
<em>low sale</em> in compared months, <strong>filter4</strong> rejects
products with the price ratio being less than 0.9 and with the
expenditure ratio being less than 0.8 in the same time.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>filter1<span class="ot">&lt;-</span><span class="fu">data_filtering</span>(milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-03&quot;</span>,</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>                        <span class="at">filters=</span><span class="fu">c</span>(<span class="st">&quot;extremeprices&quot;</span>),<span class="at">pquantiles=</span><span class="fu">c</span>(<span class="fl">0.01</span>,<span class="fl">0.99</span>))</span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>filter2<span class="ot">&lt;-</span><span class="fu">data_filtering</span>(milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-03&quot;</span>,</span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>                        <span class="at">filters=</span><span class="fu">c</span>(<span class="st">&quot;extremeprices&quot;</span>),<span class="at">plimits=</span><span class="fu">c</span>(<span class="fl">0.5</span>,<span class="dv">2</span>))</span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>filter3<span class="ot">&lt;-</span><span class="fu">data_filtering</span>(milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-03&quot;</span>,</span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>                        <span class="at">filters=</span><span class="fu">c</span>(<span class="st">&quot;extremeprices&quot;</span>,<span class="st">&quot;lowsales&quot;</span>),<span class="at">plimits=</span><span class="fu">c</span>(<span class="fl">0.5</span>,<span class="dv">2</span>))</span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>filter4<span class="ot">&lt;-</span><span class="fu">data_filtering</span>(milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-03&quot;</span>,</span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a>                        <span class="at">filters=</span><span class="fu">c</span>(<span class="st">&quot;dumpprices&quot;</span>),<span class="at">dplimits=</span><span class="fu">c</span>(<span class="fl">0.9</span>,<span class="fl">0.8</span>))</span></code></pre></div>
<p>These three filters differ from each other with regard to the data
reduction level:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>data_without_filters<span class="ot">&lt;-</span><span class="fu">data_filtering</span>(milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-03&quot;</span>,<span class="at">filters=</span><span class="fu">c</span>())</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a><span class="fu">nrow</span>(data_without_filters)</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a><span class="fu">nrow</span>(filter1)</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a><span class="fu">nrow</span>(filter2)</span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a><span class="fu">nrow</span>(filter3)</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a><span class="fu">nrow</span>(filter4)</span></code></pre></div>
<p>You can also use <strong>data_filtering</strong> for each pair of
subsequent months from the considered time interval under the condition
that this filtering is done for each outlet (<strong>retID</strong>)
separately, e.g. </p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>filter1B<span class="ot">&lt;-</span><span class="fu">data_filtering</span>(milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-03&quot;</span>,</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>                         <span class="at">filters=</span><span class="fu">c</span>(<span class="st">&quot;extremeprices&quot;</span>),<span class="at">pquantiles=</span><span class="fu">c</span>(<span class="fl">0.01</span>,<span class="fl">0.99</span>),</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>                         <span class="at">interval=</span><span class="cn">TRUE</span>, <span class="at">retailers=</span><span class="cn">TRUE</span>)</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a><span class="fu">nrow</span>(filter1B)</span></code></pre></div>
<p>Two more useful functions are included for the procedure of scanner
data. The first, <strong>data_reducing</strong>, returns a data set
containing sufficiently numerous matched products in the indicated
groups (see documentation). It reduces the dataset to only a
representative set of products that have appeared in sufficient numbers
in the sales offer:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>sugar.<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">filter</span>(sugar, time<span class="sc">==</span><span class="fu">as.Date</span>(<span class="st">&quot;2018-12-01&quot;</span>) <span class="sc">|</span> time<span class="sc">==</span><span class="fu">as.Date</span>(<span class="st">&quot;2019-12-01&quot;</span>))</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a><span class="fu">nrow</span>(sugar.)</span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>sugar_<span class="ot">&lt;-</span><span class="fu">data_reducing</span>(sugar., <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>,<span class="at">by=</span><span class="st">&quot;description&quot;</span>, <span class="at">minN=</span><span class="dv">5</span>)</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a><span class="fu">nrow</span>(sugar_)</span></code></pre></div>
<p>The second function, <strong>shrinkflation</strong>, detects and
summarises downsized and upsized products. The function detects
phenomena such as: <strong>shrinkflation</strong>,
<strong>shrinkdeflation</strong>,
<strong>sharkflation</strong>,<strong>unshrinkdeflation</strong>,
<strong>unshrinkflation</strong>, <strong>sharkdeflation</strong> (see
the <strong>type</strong> parameter). It returns a list containing the
following objects: <strong>df_changes</strong> - data frame with
detailed information on downsized and upsized products with the whole
history of size changes, <strong>df_type</strong> - data frame with
recognized type of products, <strong>df_overview</strong> - a table with
basic summary of all detected products grouped by the
<strong>type</strong> parameter, <strong>products_detected</strong> with
prodIDs of products indicated by the <strong>type</strong> parameter,
<strong>df_detected</strong> being a subset of the data frame with only
detected products, <strong>df_reduced</strong> which is the difference
of the input data frame and the data frame containing the detected
products, and <strong>df_summary</strong> which provides basic
statistics for all detected downsized and upsized products (including
their share in the total number of products and mean price and size
changes). For instance:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co">#Data matching over time</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">data_matching</span>(<span class="at">data=</span>data_DOWN_UP_SIZED, <span class="at">start=</span><span class="st">&quot;2024-01&quot;</span>, <span class="at">end=</span><span class="st">&quot;2024-02&quot;</span>, </span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>                  <span class="at">codeIN=</span><span class="cn">TRUE</span>,<span class="at">codeOUT=</span><span class="cn">TRUE</span>,<span class="at">description=</span><span class="cn">TRUE</span>,</span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>                  <span class="at">onlydescription=</span><span class="cn">FALSE</span>,<span class="at">precision=</span><span class="fl">0.9</span>,<span class="at">interval=</span><span class="cn">FALSE</span>)</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="co"># Extraction of information about grammage</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">data_unit</span>(df,<span class="at">units=</span><span class="fu">c</span>(<span class="st">&quot;g|ml|kg|l&quot;</span>),<span class="at">multiplication=</span><span class="st">&quot;x&quot;</span>)</span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co"># Price standardization</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">data_norm</span>(df, <span class="at">rules=</span><span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;ml&quot;</span>,<span class="st">&quot;l&quot;</span>,<span class="dv">1000</span>),<span class="fu">c</span>(<span class="st">&quot;g&quot;</span>,<span class="st">&quot;kg&quot;</span>,<span class="dv">1000</span>)))</span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a><span class="co"># Downsized and upsized products detection</span></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a>result<span class="ot">&lt;-</span><span class="fu">shrinkflation</span>(<span class="at">data=</span>df, <span class="at">start=</span><span class="st">&quot;2024-01&quot;</span>,<span class="st">&quot;2024-02&quot;</span>, <span class="at">prec=</span><span class="dv">3</span>, <span class="at">interval=</span><span class="cn">FALSE</span>, <span class="at">type=</span><span class="st">&quot;shrinkflation&quot;</span>)</span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a><span class="co"># result$df_changes</span></span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a>result<span class="sc">$</span>df_type</span>
<span id="cb31-13"><a href="#cb31-13" tabindex="-1"></a>result<span class="sc">$</span>df_overview</span>
<span id="cb31-14"><a href="#cb31-14" tabindex="-1"></a><span class="co"># result$products_detected</span></span>
<span id="cb31-15"><a href="#cb31-15" tabindex="-1"></a><span class="co"># result$df_detected</span></span>
<span id="cb31-16"><a href="#cb31-16" tabindex="-1"></a><span class="co"># result$df_reduced</span></span>
<span id="cb31-17"><a href="#cb31-17" tabindex="-1"></a>result<span class="sc">$</span>df_summary</span></code></pre></div>
<p><strong>MARS</strong></p>
<p>This function groups prodIDs into strata (‘products’) by balancing
two measures: an explained variance (R squared) measure for the
‘homogeneity’ of prodIDs within products, while the second expresses the
degree to which products can be ‘matched’ over time with respect to a
comparison period. The resulting product ‘match adjusted R squared’
(MARS) combines explained variance in product prices with product match
over time, so that different stratification schemes can be ranked
according to the combined measure. Any combination of attributes is
taken into account when creating stratas. For example, for a set of
attributes A, B, C, the stratas created by the following attribute
combinations are considered: A, B, C, A-B, A-C, B-C, A-B-C.The function
returns a list with the following elements: scores (with scores for
degrees of product match and product homogeneity, as well as for MARS
measure), best_partition (with the name of the partition for which the
highest indication of the MARS measure was obtained), and data_MARS
(with a data frame obtained by replacing the original prodIDs with
identifiers created based on the selected best partition). An
example:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">MARS</span>(<span class="at">data=</span>dataMARS, </span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>          <span class="at">start=</span><span class="st">&quot;2025-05&quot;</span>, </span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a>          <span class="at">end=</span><span class="st">&quot;2025-09&quot;</span>,</span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a>          <span class="at">attributes=</span><span class="fu">c</span>(<span class="st">&quot;brand&quot;</span>,<span class="st">&quot;size&quot;</span>,<span class="st">&quot;fabric&quot;</span>),</span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>          <span class="at">strategy=</span><span class="st">&quot;two_months&quot;</span>)</span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a><span class="co">#Results:</span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a>df<span class="sc">$</span>scores</span></code></pre></div>
<p><a id="ad3"> </a></p>
</div>
<div id="functions-providing-dataset-characteristics" class="section level3">
<h3>Functions providing dataset characteristics</h3>
<p><strong>available</strong></p>
<p>The function returns all values from the indicated column (defined by
the <strong>type</strong> parameter) which occur at least once in one of
compared periods or in a given time interval. Possible values of the
<strong>type</strong> parameter are: <strong>retID</strong>,
<strong>prodID</strong>, <strong>codeIN</strong>,
<strong>codeOUT</strong> or <strong>description</strong> (see
documentation). If the <strong>interval</strong> parameter is set to
FALSE, then the function compares only periods defined by
<strong>period1</strong> and <strong>period2</strong>. Otherwise the
whole time period between period1 and period2 is considered. For
example:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="fu">available</span>(milk, <span class="at">period1=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">period2=</span><span class="st">&quot;2019-12&quot;</span>, <span class="at">type=</span><span class="st">&quot;retID&quot;</span>,<span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><strong>matched</strong></p>
<p>The function returns all values from the indicated column (defined by
the <strong>type</strong> parameter) which occur simultaneously in the
compared periods or in a given time interval.Possible values of the
<strong>type</strong> parameter are: <strong>retID</strong>,
<strong>prodID</strong>, <strong>codeIN</strong>,
<strong>codeOUT</strong> or <strong>description</strong> (see
documentation). If the <strong>interval</strong> parameter is set to
FALSE, then the function compares only periods defined by
<strong>period1</strong> and <strong>period2</strong>. Otherwise the
whole time period between period1 and period2 is considered. For
example:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">matched</span>(milk, <span class="at">period1=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">period2=</span><span class="st">&quot;2019-12&quot;</span>, <span class="at">type=</span><span class="st">&quot;prodID&quot;</span>,<span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><strong>matched_index</strong></p>
<p>The function returns a ratio of values from the indicated column that
occur simultaneously in the compared periods or in a given time interval
to all available values from the above-mentioned column (defined by the
<strong>type</strong> parameter) at the same time. Possible values of
the <strong>type</strong> parameter are: <strong>retID</strong>,
<strong>prodID</strong>, <strong>codeIN</strong>,
<strong>codeOUT</strong> or <strong>description</strong> (see
documentation). If the <strong>interval</strong> parameter is set to
FALSE, then the function compares only periods defined by period1 and
period2. Otherwise the whole time period between period1 and period2 is
considered. The returned value is from 0 to 1. For example:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="fu">matched_index</span>(milk, <span class="at">period1=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">period2=</span><span class="st">&quot;2019-12&quot;</span>, <span class="at">type=</span><span class="st">&quot;prodID&quot;</span>,<span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><strong>matched_fig</strong></p>
<p>The function returns a <strong>data frame</strong> or a
<strong>figure</strong> presenting the <strong>matched_index</strong>
function calculated for the column defined by the <strong>type</strong>
parameter and for each month from the considered time interval. The
interval is set by the <strong>start</strong> and <strong>end</strong>
parameters. The returned object (data frame or figure) depends on the
value of the <strong>figure</strong> parameter. Examples:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="fu">matched_fig</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>, <span class="at">type=</span><span class="st">&quot;prodID&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="fu">matched_fig</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-04&quot;</span>, <span class="at">type=</span><span class="st">&quot;prodID&quot;</span>, <span class="at">figure=</span><span class="cn">FALSE</span>)</span></code></pre></div>
<p><strong>products</strong></p>
<p>This function detects and summarises available, matched, new and
disappearing products on the basis of their prodIDs. It compares
products from the base period (<strong>start</strong>) with products
from the current period (<strong>end</strong>). It returns a list
containing the following objects: details with prodIDs of available,
matched, new and disappearing products, statistics with basic statistics
for them and figure with a pie chart describing a contribution of
matched, new and disappearing products in a set of available products.
Please see the following example:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>list<span class="ot">&lt;-</span><span class="fu">products</span>(milk, <span class="st">&quot;2018-12&quot;</span>,<span class="st">&quot;2019-12&quot;</span>)</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>list<span class="sc">$</span>statistics</span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>list<span class="sc">$</span>figure</span></code></pre></div>
<p><strong>products_fig</strong></p>
<p>This function returns a figure with plots of volume (or
contributions) of available, matched, new as well as disappearing
products. The User may control which groups of products are to be taken
into consideration. Available options are <strong>available</strong>,
<strong>matched</strong>, <strong>new</strong> and
<strong>disappearing</strong>. Please follow the example:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fu">products_fig</span>(milk, <span class="st">&quot;2018-12&quot;</span>,<span class="st">&quot;2019-12&quot;</span>, </span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a><span class="at">fixed_base=</span><span class="cn">TRUE</span>, <span class="at">contributions=</span><span class="cn">FALSE</span>,</span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a><span class="at">show=</span><span class="fu">c</span>(<span class="st">&quot;new&quot;</span>,<span class="st">&quot;disappearing&quot;</span>,<span class="st">&quot;matched&quot;</span>,<span class="st">&quot;available&quot;</span>))</span></code></pre></div>
<p><strong>prices</strong></p>
<p>The function returns prices (unit value) of products with a given ID
(<strong>prodID</strong> column) and being sold in the time period
indicated by the <strong>period</strong> parameter. The
<strong>set</strong> parameter means a set of unique product IDs to be
used for determining prices of sold products. If the set is empty the
function returns prices of all products being available in the
<strong>period</strong>. Please note that the function returns the price
values for sorted prodIDs and in the absence of a given prodID in the
data set, the function returns nothing (it does not return zero).To get
prices (unit values) of all available milk products sold in July, 2019,
please use:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a><span class="fu">prices</span>(milk, <span class="at">period=</span><span class="st">&quot;2019-06&quot;</span>)</span></code></pre></div>
<p><strong>quantities</strong></p>
<p>The function returns quantities of products with a given ID
(<strong>prodID</strong> column) and being sold in the time period
indicated by the <strong>period</strong> parameter. The
<strong>set</strong> parameter means a set of unique product IDs to be
used for determining prices of sold products. If the set is empty the
function returns quantities of all products being available in the
<strong>period</strong>. Please note that the function returns the
quantity values for sorted prodIDs and in the absence of a given prodID
in the data set, the function returns nothing (it does not return zero).
To get a data frame containing quantities of milk products with prodIDs:
400032, 71772 and 82919, and sold in July, 2019, please use:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="fu">quantities</span>(milk, <span class="at">period=</span><span class="st">&quot;2019-06&quot;</span>, <span class="at">set=</span><span class="fu">c</span>(<span class="dv">400032</span>, <span class="dv">71772</span>, <span class="dv">82919</span>), <span class="at">ID=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><strong>sales</strong></p>
<p>The function returns values of sales of products with a given ID
(<strong>prodID</strong> column) and being sold in the time period
indicated by <strong>period</strong> parameter. The <strong>set</strong>
parameter means a set of unique product IDs to be used for determining
prices of sold products. If the set is empty the function returns values
of sales of all products being available in the <strong>period</strong>
(see also <strong>expenditures</strong> function which returns the
expenditure values for sorted prodIDs). To get values of sales of milk
products with prodIDs: 400032, 71772 and 82919, and sold in July, 2019,
please use:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="fu">sales</span>(milk, <span class="at">period=</span><span class="st">&quot;2019-06&quot;</span>, <span class="at">set=</span><span class="fu">c</span>(<span class="dv">400032</span>, <span class="dv">71772</span>, <span class="dv">82919</span>))</span></code></pre></div>
<p><strong>sales_groups</strong></p>
<p>The function returns <strong>values of sales</strong> of products
from one or more <strong>datasets</strong> or the corresponding
<strong>barplot</strong> for these sales (if <strong>barplot</strong> is
set to TRUE). Alternatively, it calculates the <strong>sale
shares</strong> (if the <strong>shares</strong> parameter is set to
TRUE). Please see also the <strong>sales_groups2</strong> function. As
an example, let us create 3 subgroups of <strong>milk</strong> products
and let us find out their sale shares for the time interval: April, 2019
- July, 2019. We can obtain precise values for the given
<strong>period</strong>:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a>ctg<span class="ot">&lt;-</span><span class="fu">unique</span>(milk<span class="sc">$</span>description)</span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>categories<span class="ot">&lt;-</span><span class="fu">c</span>(ctg[<span class="dv">1</span>],ctg[<span class="dv">2</span>],ctg[<span class="dv">3</span>])</span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a>milk1<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">filter</span>(milk, milk<span class="sc">$</span>description<span class="sc">==</span>categories[<span class="dv">1</span>])</span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>milk2<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">filter</span>(milk, milk<span class="sc">$</span>description<span class="sc">==</span>categories[<span class="dv">2</span>])</span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>milk3<span class="ot">&lt;-</span>dplyr<span class="sc">::</span><span class="fu">filter</span>(milk, milk<span class="sc">$</span>description<span class="sc">==</span>categories[<span class="dv">3</span>])</span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a><span class="fu">sales_groups</span>(<span class="at">datasets=</span><span class="fu">list</span>(milk1,milk2,milk3),<span class="at">start=</span><span class="st">&quot;2019-04&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-07&quot;</span>)</span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a><span class="fu">sales_groups</span>(<span class="at">datasets=</span><span class="fu">list</span>(milk1,milk2,milk3),<span class="at">start=</span><span class="st">&quot;2019-04&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-07&quot;</span>, <span class="at">shares=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>or a barplot presenting these results:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a><span class="fu">sales_groups</span>(<span class="at">datasets=</span><span class="fu">list</span>(milk1,milk2,milk3),<span class="at">start=</span><span class="st">&quot;2019-04&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-07&quot;</span>, </span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a>             <span class="at">barplot=</span><span class="cn">TRUE</span>, <span class="at">shares=</span><span class="cn">TRUE</span>, <span class="at">names=</span>categories)</span></code></pre></div>
<p><strong>pqcor</strong></p>
<p>The function returns <strong>Pearson’s correlation
coefficient</strong> for price and quantity of products with given IDs
(defined by the <strong>set</strong> parameter) and sold in the
<strong>period</strong>. If the <strong>set</strong> is empty, the
function works for all products being available in the
<strong>period</strong>. The <strong>figure</strong> parameter indicates
whether the function returns a figure with a correlation coefficient
(TRUE) or just a correlation coefficient (FALSE). For instance:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="fu">pqcor</span>(milk, <span class="at">period=</span><span class="st">&quot;2019-05&quot;</span>)</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="fu">pqcor</span>(milk, <span class="at">period=</span><span class="st">&quot;2019-05&quot;</span>,<span class="at">figure=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><strong>pqcor_fig</strong></p>
<p>The function returns <strong>Pearson’s correlation
coefficients</strong> between price and quantity of products with given
IDs (defined by the <strong>set</strong> parameter) and sold in the time
interval defined by the <strong>start</strong> and <strong>end</strong>
parameters. If the <strong>set</strong> is empty the function works for
all available products. Correlation coefficients are calculated for each
month separately. Results are presented in tabular or graphical form
depending on the <strong>figure</strong> parameter. Both cases are
presented below:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a><span class="fu">pqcor_fig</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-06&quot;</span>, <span class="at">figure=</span><span class="cn">FALSE</span>)</span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a><span class="fu">pqcor_fig</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-06&quot;</span>)</span></code></pre></div>
<p><strong>dissimilarity</strong></p>
<p>This function returns a value of the relative price (dSP) and/or
quantity (dSQ) dissimilarity measure. In a special case, when the
<strong>type</strong> parameter is set to <strong>pq</strong>, the
function provides the value of dSPQ measure (relative price and quantity
dissimilarity measure calculated as <strong>min(dSP,dSQ)</strong>. For
instance:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="fu">dissimilarity</span>(milk, <span class="at">period1=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">period2=</span><span class="st">&quot;2019-12&quot;</span>,<span class="at">type=</span><span class="st">&quot;pq&quot;</span>)</span></code></pre></div>
<p><strong>dissimilarity_fig</strong></p>
<p>This function presents values of the relative price and/or quantity
dissimilarity measure over time. The user can choose a benchmark period
(defined by <strong>benchmark</strong>) and the type of dissimilarity
measure is to be calculated (defined by <strong>type</strong>). The
obtained results of dissimilarities over time can be presented in a
dataframe form or via a figure (the default value of
<strong>figure</strong> is TRUE which results a figure). For
instance:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="fu">dissimilarity_fig</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>,<span class="at">type=</span><span class="st">&quot;pq&quot;</span>,<span class="at">benchmark=</span><span class="st">&quot;start&quot;</span>)</span></code></pre></div>
<p><strong>elasticity</strong></p>
<p>This function returns a value of the elasticity of substitution. If
the <strong>method</strong> parameter is set to <strong>lm</strong> (it
is a default value), the procedure of estimation solves the equation:
LM(sigma)-CW(sigma)=0 numerically, where LM denotes the Lloyd-Moulton
price index, the CW denotes a current weight counterpart of the
Lloyd-Moulton price index, and sigma is the elasticity of substitution
parameter, which is estimated. If the <strong>method</strong> parameter
is set to <strong>f</strong>, the Fisher price index formula is used
instead of the CW price index. If the <strong>method</strong> parameter
is set to <strong>t</strong>, the Tornqvist price index formula is used
instead of the CW price index. If the <strong>method</strong> parameter
is set to <strong>w</strong>, the Walsh price index formula is used
instead of the CW price index. If the <strong>method</strong> parameter
is set to <strong>sv</strong>, the Sato-Vartia price index formula is
used instead of the CW price index.The procedure continues until the
absolute value of this difference is greater than the value of the
‘precision’ parameter. For example:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="fu">elasticity</span>(coffee, <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-01&quot;</span>)</span></code></pre></div>
<p><strong>elasticity_fig</strong></p>
<p>The function provides a data frame or a figure presenting
elasticities of substitution calculated for time interval (see the
<strong>figure</strong> parameter). The elasticities of substitution can
be calculated for subsequent months or for a fixed base month (see the
<strong>start</strong> parameter) and rest of months from the given time
interval (it depends on the <strong>fixedbase</strong> parameter). The
presented function is based on the <strong>elasticity</strong> function.
For instance, to get elasticities of substitution calculated for milk
products for subsequent months we run:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a><span class="fu">elasticity_fig</span> (milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-04&quot;</span>,<span class="at">figure=</span><span class="cn">TRUE</span>, </span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a><span class="at">method=</span><span class="fu">c</span>(<span class="st">&quot;lm&quot;</span>,<span class="st">&quot;f&quot;</span>,<span class="st">&quot;sv&quot;</span>),<span class="at">names=</span><span class="fu">c</span>(<span class="st">&quot;LM&quot;</span>,<span class="st">&quot;Fisher&quot;</span>, <span class="st">&quot;SV&quot;</span>))</span></code></pre></div>
<p><a id="ad4"> </a></p>
</div>
<div id="functions-for-bilateral-unweighted-price-index-calculation" class="section level3">
<h3>Functions for bilateral unweighted price index calculation</h3>
<p>This package includes 7 functions for calculating the following
bilateral unweighted price indices:</p>
<table>
<thead>
<tr class="header">
<th>Price Index</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BMW (2007)</td>
<td>bmw</td>
</tr>
<tr class="even">
<td>Carli (1804)</td>
<td>carli</td>
</tr>
<tr class="odd">
<td>CSWD (1980,1992)</td>
<td>cswd</td>
</tr>
<tr class="even">
<td>Dutot (1738)</td>
<td>dutot</td>
</tr>
<tr class="odd">
<td>Jevons (1865)</td>
<td>jevons</td>
</tr>
<tr class="even">
<td>Harmonic</td>
<td>harmonic</td>
</tr>
<tr class="odd">
<td>Dikhanov (2021, 2024)</td>
<td>dikhanov</td>
</tr>
</tbody>
</table>
<p>Each of these functions returns a value (or vector of values) of the
choosen unweighted bilateral price index depending on the
<strong>interval</strong> parameter. If the interval parameter is set to
TRUE, the function returns a vector of price index values without dates.
To get information about both price index values and corresponding dates
please see general functions: <strong>price_indices</strong> or
<strong>final_index</strong>. None of these functions takes into account
aggregating over outlets or product subgroups (to consider these types
of aggregating please use the <strong>final_index</strong> function.)
Below are examples of calculations for the Jevons index (in the second
case a <em>fixed base month</em> is set to December 2018):</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="fu">jevons</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-01&quot;</span>)</span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a><span class="fu">jevons</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-01&quot;</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><a id="ad5"> </a></p>
</div>
<div id="functions-for-bilateral-weighted-price-index-calculation" class="section level3">
<h3>Functions for bilateral weighted price index calculation</h3>
<p>This package includes 30 functions for calculating the following
bilateral weighted price indices:</p>
<table>
<thead>
<tr class="header">
<th>Price Index</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AG Mean (2009)</td>
<td>agmean</td>
</tr>
<tr class="even">
<td>Banajree (1977)</td>
<td>banajree</td>
</tr>
<tr class="odd">
<td>Bialek (2012,2013)</td>
<td>bialek</td>
</tr>
<tr class="even">
<td>Davies (1924)</td>
<td>davies</td>
</tr>
<tr class="odd">
<td>Drobisch (1871)</td>
<td>drobisch</td>
</tr>
<tr class="even">
<td>Fisher (1922)</td>
<td>fisher</td>
</tr>
<tr class="odd">
<td>Geary-Khamis (1958,1970)</td>
<td>geary_khamis</td>
</tr>
<tr class="even">
<td>Geo-Laspeyres</td>
<td>geolaspeyres</td>
</tr>
<tr class="odd">
<td>Geo-Lowe</td>
<td>geolowe</td>
</tr>
<tr class="even">
<td>Geo-Paasche</td>
<td>geopaasche</td>
</tr>
<tr class="odd">
<td>Geo-Young</td>
<td>geoyoung</td>
</tr>
<tr class="even">
<td>Geo-hybrid (2020)</td>
<td>geohybrid</td>
</tr>
<tr class="odd">
<td>Hybrid (2020)</td>
<td>hybrid</td>
</tr>
<tr class="even">
<td>Laspeyres (1871)</td>
<td>laspeyres</td>
</tr>
<tr class="odd">
<td>Lehr (1885)</td>
<td>lehr</td>
</tr>
<tr class="even">
<td>Lloyd-Moulton (1975,1996)</td>
<td>lloyd_moulton</td>
</tr>
<tr class="odd">
<td>Lowe</td>
<td>lowe</td>
</tr>
<tr class="even">
<td>Marshall-Edgeworth (1887)</td>
<td>marshall_edgeworth</td>
</tr>
<tr class="odd">
<td>Paasche (1874)</td>
<td>paasche</td>
</tr>
<tr class="even">
<td>Palgrave (1886)</td>
<td>palgrave</td>
</tr>
<tr class="odd">
<td>Sato-Vartia (1976)</td>
<td>sato_vartia</td>
</tr>
<tr class="even">
<td>Stuvel (1957)</td>
<td>stuvel</td>
</tr>
<tr class="odd">
<td>Tornqvist (1936)</td>
<td>tornqvist</td>
</tr>
<tr class="even">
<td>Vartia (1976)</td>
<td>vartia</td>
</tr>
<tr class="odd">
<td>Walsh (1901)</td>
<td>walsh</td>
</tr>
<tr class="even">
<td>Young</td>
<td>young</td>
</tr>
<tr class="odd">
<td>Quadratic mean of order r price index</td>
<td>QMp</td>
</tr>
<tr class="even">
<td>Implicit quadratic mean of order r price index</td>
<td>IQMp</td>
</tr>
<tr class="odd">
<td>Value Index</td>
<td>value_index</td>
</tr>
<tr class="even">
<td>Unit Value Index</td>
<td>unit_value_index</td>
</tr>
</tbody>
</table>
<p>and the general quadratic mean of order r quantity index: QMq.</p>
<p>Each of these functions returns a value (or vector of values) of the
choosen weighted bilateral price index depending on the
<strong>interval</strong> parameter. If interval parameter is set to
TRUE, the function returns a vector of price index values without dates.
To get information about both price index values and corresponding dates
please see general functions: <strong>price_indices</strong> or
<strong>final_index</strong>. None of these functions takes into account
aggregating over outlets or product subgroups (to consider these types
of aggregating please use the <strong>final_index</strong> function.)
Below are examples of calculations for the Fisher, the Lloyd-Moulton and
the Lowe indices (in the last case, the <em>fixed base month</em> is set
to December 2019 and the <em>prior</em> period is December 2018):</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a><span class="fu">fisher</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-01&quot;</span>)</span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a><span class="fu">lloyd_moulton</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-01&quot;</span>, <span class="at">sigma=</span><span class="fl">0.9</span>)</span>
<span id="cb53-3"><a href="#cb53-3" tabindex="-1"></a><span class="fu">lowe</span>(milk, <span class="at">start=</span><span class="st">&quot;2019-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-02&quot;</span>, <span class="at">base=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><a id="ad6"> </a></p>
</div>
<div id="functions-for-chain-price-index-calculation" class="section level3">
<h3>Functions for chain price index calculation</h3>
<p>This package includes 36 functions for calculating the following
chain indices (weighted and unweighted):</p>
<table>
<thead>
<tr class="header">
<th>Price Index</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chain BMW</td>
<td>chbmw</td>
</tr>
<tr class="even">
<td>Chain Carli</td>
<td>chcarli</td>
</tr>
<tr class="odd">
<td>Chain CSWD</td>
<td>chcswd</td>
</tr>
<tr class="even">
<td>Chain Dutot</td>
<td>chdutot</td>
</tr>
<tr class="odd">
<td>Chain Jevons</td>
<td>chjevons</td>
</tr>
<tr class="even">
<td>Chain Harmonic</td>
<td>chharmonic</td>
</tr>
<tr class="odd">
<td>Chain Dikhanov</td>
<td>chdikhanov</td>
</tr>
<tr class="even">
<td>Chain AG Mean</td>
<td>chagmean</td>
</tr>
<tr class="odd">
<td>Chain Banajree</td>
<td>chbanajree</td>
</tr>
<tr class="even">
<td>Chain Bialek</td>
<td>chbialek</td>
</tr>
<tr class="odd">
<td>Chain Davies</td>
<td>chdavies</td>
</tr>
<tr class="even">
<td>Chain Drobisch</td>
<td>chdrobisch</td>
</tr>
<tr class="odd">
<td>Chain Fisher</td>
<td>chfisher</td>
</tr>
<tr class="even">
<td>Chain Geary-Khamis</td>
<td>chgeary_khamis</td>
</tr>
<tr class="odd">
<td>Chain Geo-Laspeyres</td>
<td>chgeolaspeyres</td>
</tr>
<tr class="even">
<td>Chain Geo-Lowe</td>
<td>chgeolowe</td>
</tr>
<tr class="odd">
<td>Chain Geo-Paasche</td>
<td>chgeopaasche</td>
</tr>
<tr class="even">
<td>Chain Geo-Young</td>
<td>chgeoyoung</td>
</tr>
<tr class="odd">
<td>Chain Geo-hybrid</td>
<td>chgeohybrid</td>
</tr>
<tr class="even">
<td>Chain Hybrid</td>
<td>chhybrid</td>
</tr>
<tr class="odd">
<td>Chain Laspeyres</td>
<td>chlaspeyres</td>
</tr>
<tr class="even">
<td>Chain Lehr</td>
<td>chlehr</td>
</tr>
<tr class="odd">
<td>Chain Lloyd-Moulton</td>
<td>chlloyd_moulton</td>
</tr>
<tr class="even">
<td>Chain Lowe</td>
<td>chlowe</td>
</tr>
<tr class="odd">
<td>Chain Marshall-Edgeworth</td>
<td>chmarshall_edgeworth</td>
</tr>
<tr class="even">
<td>Chain Paasche</td>
<td>chpaasche</td>
</tr>
<tr class="odd">
<td>Chain Palgrave</td>
<td>chpalgrave</td>
</tr>
<tr class="even">
<td>Chain Sato-Vartia</td>
<td>chsato_vartia</td>
</tr>
<tr class="odd">
<td>Chain Stuvel</td>
<td>chstuvel</td>
</tr>
<tr class="even">
<td>Chain Tornqvist</td>
<td>chtornqvist</td>
</tr>
<tr class="odd">
<td>Chain Vartia</td>
<td>chvartia</td>
</tr>
<tr class="even">
<td>Chain Walsh</td>
<td>chwalsh</td>
</tr>
<tr class="odd">
<td>Chain Young</td>
<td>chyoung</td>
</tr>
<tr class="even">
<td>Chain quadratic mean of order r price index</td>
<td>chQMp</td>
</tr>
<tr class="odd">
<td>Chain implicit quadratic mean of order r price index</td>
<td>chIQMp</td>
</tr>
<tr class="even">
<td>Chain quadratic mean of order r quantity index</td>
<td>chQMq</td>
</tr>
</tbody>
</table>
<p>Each time, the <strong>interval</strong> parameter has a logical
value indicating whether the function is to compare the research period
defined by <strong>end</strong> to the base period defined by
<strong>start</strong> (then <strong>interval</strong> is set to FALSE
and it is a default value) or all fixed base indices are to be
calculated. In this second case, all months from the time interval
<strong>&lt;start,end&gt;</strong> are considered and
<strong>start</strong> defines the base period
(<strong>interval</strong> is set to TRUE). Here are examples for the
Fisher chain index:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="fu">chfisher</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-01&quot;</span>)</span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a><span class="fu">chfisher</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-01&quot;</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><a id="ad7"> </a></p>
</div>
<div id="functions-for-multilateral-price-index-calculation" class="section level3">
<h3>Functions for multilateral price index calculation</h3>
<p>This package includes 22 functions for calculating multilateral price
indices and one additional and general function (<strong>QU</strong>)
which calculates the quality adjusted unit value index, i.e.:</p>
<table>
<thead>
<tr class="header">
<th>Price Index</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CCDI</td>
<td>ccdi</td>
</tr>
<tr class="even">
<td>GEKS</td>
<td>geks</td>
</tr>
<tr class="odd">
<td>WGEKS</td>
<td>wgeks</td>
</tr>
<tr class="even">
<td>GEKS-J</td>
<td>geksj</td>
</tr>
<tr class="odd">
<td>GEKS-W</td>
<td>geksw</td>
</tr>
<tr class="even">
<td>GEKS-L</td>
<td>geksl</td>
</tr>
<tr class="odd">
<td>WGEKS-L</td>
<td>wgeksl</td>
</tr>
<tr class="even">
<td>GEKS-GL</td>
<td>geksgl</td>
</tr>
<tr class="odd">
<td>WGEKS-GL</td>
<td>wgeksgl</td>
</tr>
<tr class="even">
<td>GEKS-AQU</td>
<td>geksaqu</td>
</tr>
<tr class="odd">
<td>WGEKS-AQU</td>
<td>wgeksaqu</td>
</tr>
<tr class="even">
<td>GEKS-AQI</td>
<td>geksaqi</td>
</tr>
<tr class="odd">
<td>WGEKS-AQI</td>
<td>wgeksaqi</td>
</tr>
<tr class="even">
<td>GEKS-GAQI</td>
<td>geksgaqi</td>
</tr>
<tr class="odd">
<td>GEKS-IQM</td>
<td>geksiqm</td>
</tr>
<tr class="even">
<td>GEKS-QM</td>
<td>geksqm</td>
</tr>
<tr class="odd">
<td>GEKS-LM</td>
<td>gekslm</td>
</tr>
<tr class="even">
<td>WGEKS-GAQI</td>
<td>wgeksgaqi</td>
</tr>
<tr class="odd">
<td>Geary-Khamis</td>
<td>gk</td>
</tr>
<tr class="even">
<td>Quality Adjusted Unit Value</td>
<td>QU</td>
</tr>
<tr class="odd">
<td>Time Product Dummy</td>
<td>tpd</td>
</tr>
<tr class="even">
<td>Unweighted Time Product Dummy</td>
<td>utpd</td>
</tr>
<tr class="odd">
<td>SPQ</td>
<td>SPQ</td>
</tr>
</tbody>
</table>
<p>The above-mentioned 21 multilateral formulas (the
<strong>SPQ</strong> index is an exception) consider the time window
defined by the <strong>wstart</strong> and <strong>window</strong>
parameters, where <strong>window</strong> is a length of the time window
(typically multilateral methods are based on a 13-month time window). It
measures the price dynamics by comparing the <strong>end</strong> period
to the <strong>start</strong> period (both <strong>start</strong> and
<strong>end</strong> must be inside the considered time window). To get
information about both price index values and corresponding dates,
please see functions: <strong>price_indices</strong> or
<strong>final_index</strong>. These functions do not take into account
aggregating over outlets or product subgroups (to consider these types
of aggregating please use function: <strong>final_index</strong> ). Here
are examples for the GEKS formula (see documentation):</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a><span class="fu">geks</span>(milk, <span class="at">start=</span><span class="st">&quot;2019-01&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-04&quot;</span>,<span class="at">window=</span><span class="dv">10</span>)</span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a><span class="fu">geksl</span>(milk, <span class="at">wstart=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">start=</span><span class="st">&quot;2019-03&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-05&quot;</span>)</span></code></pre></div>
<p>The user may decompose the GEKS-type indices. The
<strong>m_decomposition</strong> function returns multiplicative
decompositions of the selected GEKS-type indices. For instance:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a>milk.<span class="ot">&lt;-</span>milk</span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>milk.<span class="sc">$</span>prodID<span class="ot">&lt;-</span>milk.<span class="sc">$</span>description</span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a><span class="fu">m_decomposition</span>(milk., <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>,</span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a>                <span class="at">formula=</span><span class="fu">c</span>(<span class="st">&quot;geks&quot;</span>,<span class="st">&quot;ccdi&quot;</span>))<span class="sc">$</span>multiplicative</span></code></pre></div>
<p>The <strong>QU</strong> function returns a value of the <em>quality
adjusted unit value index</em> (QU index) for the given set of
adjustment factors. An additional <strong>v</strong> parameter is a data
frame with adjustment factors for at least all matched
<strong>prodIDs</strong>. It must contain two columns:
<strong>prodID</strong> with unique product IDs and
<strong>value</strong> with corresponding adjustment factors (see
documentation). The following example starts from creating a data frame
which includes sample adjusted factors:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a>prodID<span class="ot">&lt;-</span>base<span class="sc">::</span><span class="fu">unique</span>(milk<span class="sc">$</span>prodID)</span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>values<span class="ot">&lt;-</span>stats<span class="sc">::</span><span class="fu">runif</span>(<span class="fu">length</span>(prodID),<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a>v<span class="ot">&lt;-</span><span class="fu">data.frame</span>(prodID,values)</span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a><span class="fu">head</span>(v)</span></code></pre></div>
<p>and the next step is calculating the QU index which compares December
2019 to December 2018:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="fu">QU</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>, v)</span></code></pre></div>
<p><a id="ad8"> </a></p>
</div>
<div id="functions-for-extending-multilateral-price-indices-by-using-splicing-methods" class="section level3">
<h3>Functions for extending multilateral price indices by using splicing
methods</h3>
<p>This package includes 21 functions for calculating splice
indices:</p>
<table>
<thead>
<tr class="header">
<th>Price Index</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Splice CCDI</td>
<td>ccdi_splcie</td>
</tr>
<tr class="even">
<td>Splice GEKS</td>
<td>geks_splice</td>
</tr>
<tr class="odd">
<td>Splice weighted GEKS</td>
<td>wgeks_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-J</td>
<td>geksj_splice</td>
</tr>
<tr class="odd">
<td>Splice GEKS-W</td>
<td>geksw_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-L</td>
<td>geksl_splice</td>
</tr>
<tr class="odd">
<td>Splice weighted GEKS-L</td>
<td>wgeksl_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-GL</td>
<td>geksgl_splice</td>
</tr>
<tr class="odd">
<td>Splice weighted GEKS-GL</td>
<td>wgeksgl_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-AQU</td>
<td>geksaqu_splice</td>
</tr>
<tr class="odd">
<td>Splice weighted GEKS-AQU</td>
<td>wgeksaqu_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-AQI</td>
<td>geksaqi_splice</td>
</tr>
<tr class="odd">
<td>Splice weighted GEKS-AQI</td>
<td>wgeksaqi_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-GAQI</td>
<td>geksgaqi_splice</td>
</tr>
<tr class="odd">
<td>Splice weighted GEKS-GAQI</td>
<td>wgeksgaqi_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-IQM</td>
<td>geksiqm_splice</td>
</tr>
<tr class="odd">
<td>Splice GEKS-QM</td>
<td>geksqm_splice</td>
</tr>
<tr class="even">
<td>Splice GEKS-LM</td>
<td>gekslm_splice</td>
</tr>
<tr class="odd">
<td>Splice Geary-Khamis</td>
<td>gk_splice</td>
</tr>
<tr class="even">
<td>Splice Time Product Dummy</td>
<td>tpd_splice</td>
</tr>
<tr class="odd">
<td>Splice unweighted Time Product Dummy</td>
<td>utpd_splice</td>
</tr>
</tbody>
</table>
<p>These functions return a value (or values) of the selected
multilateral price index extended by using window splicing methods
(defined by the <strong>splice</strong> parameter). Available splicing
methods are: <strong>movement splice</strong>, <strong>window
splice</strong>, <strong>half splice</strong>, <strong>mean
splice</strong> and their additional variants: <strong>window splice on
published indices (WISP)</strong>, <strong>half splice on published
indices (HASP)</strong> and <strong>mean splice on published
indices</strong> (see documentation). The first considered time window
is defined by the <strong>start</strong> and <strong>window</strong>
parameters, where <strong>window</strong> is a length of the time window
(typically multilateral methods are based on a 13-month time window).
Functions measure the price dynamics by comparing the
<strong>end</strong> period to the <strong>start</strong> period,
i.e. if the time interval <strong>&lt;start, end&gt;</strong> exceeds
the defined time window then splicing methods are used. If the
<strong>interval</strong> parameter is set to TRUE, then all fixed base
multilateral indices are presented (the fixed base month is defined by
<strong>start</strong>). To get information about both price index
values and corresponding dates, please see functions:
<strong>price_indices</strong> or <strong>final_index</strong>. These
functions do not take into account aggregating over outlets or product
subgroups (to consider these types of aggregating, please use the
<strong>final_index</strong> function). For instance, let us calculate
the <strong>extended Time Product Dummy</strong> index by using the
<strong>half splice method</strong> with a 10-month time window:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="fu">tpd_splice</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-02&quot;</span>,<span class="at">window=</span><span class="dv">10</span>,<span class="at">splice=</span><span class="st">&quot;half&quot;</span>,<span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><a id="ad9"> </a></p>
</div>
<div id="functions-for-extending-multilateral-price-indices-by-using-the-fbew-method" class="section level3">
<h3>Functions for extending multilateral price indices by using the FBEW
method</h3>
<p>This package includes 21 functions for calculating extensions of
multilateral indices by using the Fixed Base Monthly Expanding Window
(FBEW) method:</p>
<table>
<thead>
<tr class="header">
<th>Price Index</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FBEW CCDI</td>
<td>ccdi_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS</td>
<td>geks_fbew</td>
</tr>
<tr class="odd">
<td>FBEW WGEKS</td>
<td>wgeks_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-J</td>
<td>geksj_fbew</td>
</tr>
<tr class="odd">
<td>FBEW GEKS-W</td>
<td>geksw_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-L</td>
<td>geksl_fbew</td>
</tr>
<tr class="odd">
<td>FBEW WGEKS-L</td>
<td>wgeksl_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-GL</td>
<td>geksgl_fbew</td>
</tr>
<tr class="odd">
<td>FBEW WGEKS-GL</td>
<td>wgeksgl_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-AQU</td>
<td>geksaqu_fbew</td>
</tr>
<tr class="odd">
<td>FBEW WGEKS-AQU</td>
<td>wgeksaqu_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-AQI</td>
<td>geksaqi_fbew</td>
</tr>
<tr class="odd">
<td>FBEW WGEKS-AQI</td>
<td>wgeksaqi_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-GAQI</td>
<td>geksgaqi_fbew</td>
</tr>
<tr class="odd">
<td>FBEW WGEKS-GAQI</td>
<td>wgeksgaqi_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-QM</td>
<td>geksqm_fbew</td>
</tr>
<tr class="odd">
<td>FBEW GEKS-IQM</td>
<td>geksiqm_fbew</td>
</tr>
<tr class="even">
<td>FBEW GEKS-LM</td>
<td>gekslm_fbew</td>
</tr>
<tr class="odd">
<td>FBEW Geary-Khamis</td>
<td>gk_fbew</td>
</tr>
<tr class="even">
<td>FBEW Time Product Dummy</td>
<td>tpd_fbew</td>
</tr>
<tr class="odd">
<td>FBEW unweighted Time Product Dummy</td>
<td>utpd_fbew</td>
</tr>
</tbody>
</table>
<p>These functions return a value (or values) of the selected
multilateral price index extended by using the FBEW method. The FBEW
method uses a time window with a fixed base month every year (December).
The window is enlarged every month with one month in order to include
information from a new month. The full window length (13 months) is
reached in December of each year. These functions measure the price
dynamics between the <strong>end</strong> and <strong>start</strong>
periods. A month of the <strong>start</strong> parameter must be
December (see documentation). If the distance between
<strong>end</strong> and <strong>start</strong> exceeds 13 months, then
internal Decembers play a role of chain-linking months. To get
information about both price index values and corresponding dates please
see functions: <strong>price_indices</strong> or
<strong>final_index</strong>. These functions do not take into account
aggregating over outlets or product subgroups (to consider these types
of aggregating, please use the <strong>final_index</strong> function).
For instance, let us calculate the <strong>extended GEKS</strong> index
by using the FBEW method. Please note that December 2019 is the
chain-linking month, i.e.:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="fu">geks_fbew</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-03&quot;</span>)</span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>  <span class="fu">geks_fbew</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>)<span class="sc">*</span></span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>  <span class="fu">geks_fbew</span>(milk, <span class="at">start=</span><span class="st">&quot;2019-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-03&quot;</span>)</span></code></pre></div>
<p><a id="ad10"> </a></p>
</div>
<div id="functions-for-extending-multilateral-price-indices-by-using-the-fbmw-method" class="section level3">
<h3>Functions for extending multilateral price indices by using the FBMW
method</h3>
<p>This package includes 21 functions for calculating extensions of
multilateral indices by using the Fixed Base Moving Window (FBMW)
method:</p>
<table>
<thead>
<tr class="header">
<th>Price Index</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FBMW CCDI</td>
<td>ccdi_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS</td>
<td>geks_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW WGEKS</td>
<td>wgeks_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-J</td>
<td>geksj_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW GEKS-W</td>
<td>geksw_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-L</td>
<td>geksl_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW WGEKS-L</td>
<td>wgeksl_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-GL</td>
<td>geksgl_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW WGEKS-GL</td>
<td>wgeksgl_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-AQU</td>
<td>geksaqu_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW WGEKS-AQU</td>
<td>wgeksaqu_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-AQI</td>
<td>geksaqi_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW WGEKS-AQI</td>
<td>wgeksaqi_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-GAQI</td>
<td>geksgaqi_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW WGEKS-GAQI</td>
<td>wgeksgaqi_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-IQM</td>
<td>geksiqm_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW GEKS-QM</td>
<td>geksqm_fbmw</td>
</tr>
<tr class="even">
<td>FBMW GEKS-LM</td>
<td>gekslm_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW Geary-Khamis</td>
<td>gk_fbmw</td>
</tr>
<tr class="even">
<td>FBMW Time Product Dummy</td>
<td>tpd_fbmw</td>
</tr>
<tr class="odd">
<td>FBMW unweighted Time Product Dummy</td>
<td>utpd_fbmw</td>
</tr>
</tbody>
</table>
<p>These functions return a value (or values) of the selected
multilateral price index extended by using the FBMW method. They measure
the price dynamics between the <strong>end</strong> and
<strong>start</strong> periods and it uses a 13-month time window with a
fixed base month taken as <strong>year(end)-1</strong>. If the distance
between <strong>end</strong> and <strong>start</strong> exceeds 13
months, then internal Decembers play a role of chain-linking months. A
month of the <strong>start</strong> parameter must be December (see
documentation). To get information about both price index values and
corresponding dates, please see functions:
<strong>price_indices</strong> or <strong>final_index</strong>. These
functions do not take into account aggregating over outlets or product
subgroups (to consider these types of aggregating, please use the
<strong>final_index</strong> function). For instance, let us calculate
the <strong>extended CCDI</strong> index by using the FBMW method.
Please note that December 2019 is the chain-linking month, i.e.:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a><span class="fu">ccdi_fbmw</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-03&quot;</span>)</span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a>    <span class="fu">ccdi_fbmw</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>)<span class="sc">*</span></span>
<span id="cb61-3"><a href="#cb61-3" tabindex="-1"></a>    <span class="fu">ccdi_fbmw</span>(milk, <span class="at">start=</span><span class="st">&quot;2019-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2020-03&quot;</span>)</span></code></pre></div>
<p><a id="ad11"> </a></p>
</div>
<div id="general-functions-for-price-index-calculations" class="section level3">
<h3>General functions for price index calculations</h3>
<p>This package includes 3 general functions for price index
calculation. The <strong>start</strong> and <strong>end</strong>
parameters indicate the base and the research period respectively. These
function provide value or values (depending on the
<strong>interval</strong> parameter) of the selected price index formula
or formulas. If the <strong>interval</strong> parameter is set to
<strong>TRUE</strong> then it returns a data frame with two columns:
<strong>dates</strong> and <strong>index values</strong>. Function
<strong>price_indices</strong> does not take into account aggregating
over outlets or product subgroups and to consider these types of
aggregating, please use function: <strong>final_index</strong>.</p>
<p><strong>price_indices</strong></p>
<p>This function allows us to compare many price index formulas by using
one command. The general character of this function mean that, for
instance, your one command may calculate two CES indices for two
different values of <strong>sigma</strong> parameter (the elasticity of
substitution) or you can select several splice indices and calculate
them by using different window lengths and different splicing method.
You can control names of columns in the resulting data frame by defining
additional parameters: <strong>names</strong>. Please note that this
function is not the most general in the package, i.e. all selected price
indices are calculated for the same data set defined by the
<strong>data</strong> parameter and the aggregation over subgroups or
outlets are not taken into consideration here (to consider it, please
use function: <strong>final_index</strong>).</p>
<p>For instance:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="fu">price_indices</span>(milk, </span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>         <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>,</span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a>         <span class="at">formula=</span><span class="fu">c</span>(<span class="st">&quot;geks&quot;</span>,<span class="st">&quot;ccdi&quot;</span>,<span class="st">&quot;hybrid&quot;</span>,<span class="st">&quot;fisher&quot;</span>,</span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a>         <span class="st">&quot;QMp&quot;</span>,<span class="st">&quot;young&quot;</span>,<span class="st">&quot;geksl_fbew&quot;</span>),</span>
<span id="cb62-5"><a href="#cb62-5" tabindex="-1"></a>         <span class="at">window =</span> <span class="fu">c</span>(<span class="dv">13</span>, <span class="dv">13</span>),</span>
<span id="cb62-6"><a href="#cb62-6" tabindex="-1"></a>         <span class="at">base =</span> <span class="fu">c</span>(<span class="st">&quot;2019-03&quot;</span>, <span class="st">&quot;2019-03&quot;</span>),</span>
<span id="cb62-7"><a href="#cb62-7" tabindex="-1"></a>         <span class="at">r=</span><span class="fu">c</span>(<span class="dv">3</span>), <span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="fu">price_indices</span>(coffee, </span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>         <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>,</span>
<span id="cb63-3"><a href="#cb63-3" tabindex="-1"></a>         <span class="at">formula=</span><span class="fu">c</span>(<span class="st">&quot;laspeyres&quot;</span>,<span class="st">&quot;paasche&quot;</span>,<span class="st">&quot;fisher&quot;</span>),</span>
<span id="cb63-4"><a href="#cb63-4" tabindex="-1"></a>         <span class="at">interval=</span><span class="cn">FALSE</span>)</span></code></pre></div>
<p><strong>final_index</strong></p>
<p>This general function returns a value or values of the selected final
price index for the selected type of aggregation of partial results. If
the interval parameter is set to TRUE, then it returns a data frame
where its first column indicates dates and the remaining columns show
corresponding values of all selected price index. A final price index
formula can be any index formula which is available in the PriceIdices
packages (bilateral or multilateral). The formula used for aggregating
partial index results is selected by the <strong>aggr</strong> parameter
and the User decides on directions of aggregation (see
<strong>outlets</strong> and <strong>groups</strong> parameters).</p>
<p><strong>Example</strong>. Let us calculate the final Fisher price
index (with Laspeyres-type aggregation over outlets and product
subgroups) for the data set on <strong>milk</strong></p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">final_index</span>(milk, <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>, </span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a>         <span class="at">formula =</span> <span class="st">&quot;fisher&quot;</span>, <span class="at">groups =</span> <span class="cn">TRUE</span>, <span class="at">outlets =</span> <span class="cn">TRUE</span>, </span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a>         <span class="at">aggr =</span> <span class="st">&quot;laspeyres&quot;</span>, <span class="at">by =</span> <span class="st">&quot;description&quot;</span>, </span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>         <span class="at">interval =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p><a id="ad12"> </a></p>
</div>
<div id="functions-for-comparisons-of-price-indices" class="section level3">
<h3>Functions for comparisons of price indices</h3>
<p>This package includes two functions for a simple graphical comparison
of price indices and two functions for calculating distances between
indices. The first one, i.e. <strong>compare_indices_df</strong>, is
based on the syntax of the <strong>price_indices</strong> function and
thus it allows us to compare price indices calculated on the same data
set. The second function, i.e. <strong>compare_indices_list</strong>,
has a general character since its first argument is a list of data
frames which contain results obtained by using the
<strong>price_indices</strong> or <strong>final_index</strong>
functions. The third one, i.e. <strong>compare_distances</strong>,
calculates (average) distances between price indices, i.e. the mean
absolute distance or root mean square distance is calculated. The next
function, <strong>compare_to_target</strong>, allows to compute
distances between indices from the selected index group and the
indicated target price index. The last function,
<strong>compare_indices_jk</strong>, presents a comparison of selected
indices obtained by using the jackknife method.</p>
<p><strong>compare_indices_df</strong> and
<strong>compare_indices_list</strong></p>
<p>These functions return a figure with plots of selected price indices,
which are provided as a data frame (<strong>compare_indices_df</strong>)
or a list of data frames (<strong>compare_indices_list</strong>). For
instance, let us compare the Laspeyres and Paasche indices calculated
for the data set on milk:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">price_indices</span>(milk, <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>, </span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a><span class="at">formula=</span><span class="fu">c</span>(<span class="st">&quot;laspeyres&quot;</span>, <span class="st">&quot;fisher&quot;</span>), <span class="at">interval =</span> <span class="cn">TRUE</span>)</span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a><span class="fu">compare_indices_df</span>(df)</span></code></pre></div>
<p>Now, let us compare the impact of the aggregating over outlets on the
price index results (e.g. the Laspeyres formula is the assumed
aggregating method). For this purpose, let us calculate the Fisher price
index in two cases: <strong>case1</strong> without the above-mentioned
aggregation and <strong>case2</strong> which considers that aggregation.
We use the <strong>milk</strong> dataset and the yearly time
interval:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a>case1<span class="ot">&lt;-</span><span class="fu">price_indices</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>,</span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>                   <span class="at">formula=</span><span class="st">&quot;fisher&quot;</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>case2<span class="ot">&lt;-</span><span class="fu">final_index</span>(milk, <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>, <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>, </span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a>                   <span class="at">formula=</span><span class="st">&quot;fisher&quot;</span>,</span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a>                   <span class="at">outlets=</span><span class="cn">TRUE</span>, </span>
<span id="cb66-6"><a href="#cb66-6" tabindex="-1"></a>                   <span class="at">aggr =</span> <span class="st">&quot;laspeyres&quot;</span>, </span>
<span id="cb66-7"><a href="#cb66-7" tabindex="-1"></a>                   <span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>The comparison of obtained results can be made as follows:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a><span class="fu">compare_indices_list</span>(<span class="at">data=</span><span class="fu">list</span>(case1, case2), </span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a>                <span class="at">names=</span><span class="fu">c</span>(<span class="st">&quot;Fisher without aggregation&quot;</span>,</span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a>                <span class="st">&quot;Fisher with aggregation&quot;</span>))</span></code></pre></div>
<p><strong>compare_distances</strong></p>
<p>The function calculates average distances between price indices and
it returns a data frame with these values for each pair of price
indices. The main <strong>data</strong> parameter is a data frame
containing values of indices which are to be compared. The
<strong>measure</strong> parameter specifies what measure should be used
to compare the indexes. Possible parameter values are: “MAD” (Mean
Absolute Distance) or “RMSD” (Root Mean Square Distance). The results
may be presented in percentage points (see the <strong>pp</strong>
parameter) and we can control how many decimal places are to be used in
the presentation of results (see the <strong>prec</strong>
parameter).</p>
<p>For instance, let us compare the Jevons, Dutot and Carli indices
calculated for the <strong>milk</strong> data set and for the time
interval: December 2018 - December 2019. Let us use the MAD measure for
these comparisons:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="co">#Creating a data frame with unweighted bilateral index values</span></span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">price_indices</span>(milk, </span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a>                  <span class="at">formula=</span><span class="fu">c</span>(<span class="st">&quot;jevons&quot;</span>,<span class="st">&quot;dutot&quot;</span>,<span class="st">&quot;carli&quot;</span>), </span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a>                  <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,</span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a>                  <span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>,</span>
<span id="cb68-6"><a href="#cb68-6" tabindex="-1"></a>                  <span class="at">interval=</span><span class="cn">TRUE</span>)</span>
<span id="cb68-7"><a href="#cb68-7" tabindex="-1"></a><span class="co">#Calculating average distances between indices (in p.p)</span></span>
<span id="cb68-8"><a href="#cb68-8" tabindex="-1"></a><span class="fu">compare_distances</span>(df)</span></code></pre></div>
<p><strong>compare_to_target</strong></p>
<p>The function calculates average distances between considered price
indices and the target price index and it returns a data frame with:
average distances on the basis of all values of compared indices
(<strong>distance</strong> column), average semi-distances on the basis
of values of compared indices which overestimate the target index values
(<strong>distance_upper</strong> column) and average semi-distances on
the basis of values of compared indices which underestimate the target
index values (<strong>distance_lower</strong> column).</p>
<p>For instance, let us compare the Jevons, Laspeyres, Paasche and Walsh
price indices (calculated for the <strong>milk</strong> data set and for
the time interval: December 2018 - December 2019) with the target Fisher
price index:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a><span class="co">#Creating a data frame with example bilateral indices</span></span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>df<span class="ot">&lt;-</span><span class="fu">price_indices</span>(milk, </span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>                  <span class="at">formula=</span><span class="fu">c</span>(<span class="st">&quot;jevons&quot;</span>,<span class="st">&quot;laspeyres&quot;</span>,<span class="st">&quot;paasche&quot;</span>,<span class="st">&quot;walsh&quot;</span>),</span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a>                  <span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>,<span class="at">interval=</span><span class="cn">TRUE</span>)</span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a><span class="co">#Calculating the target Fisher price index</span></span>
<span id="cb69-6"><a href="#cb69-6" tabindex="-1"></a>target_index<span class="ot">&lt;-</span><span class="fu">fisher</span>(milk,<span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,<span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>,<span class="at">interval=</span><span class="cn">TRUE</span>)</span>
<span id="cb69-7"><a href="#cb69-7" tabindex="-1"></a><span class="co">#Calculating average distances between considered indices and the Fisher index (in p.p)</span></span>
<span id="cb69-8"><a href="#cb69-8" tabindex="-1"></a><span class="fu">compare_to_target</span>(df,<span class="at">target=</span>target_index)</span></code></pre></div>
<p><strong>compare_indices_jk</strong></p>
<p>This function presents a comparison of selected indices obtained by
using the jackknife method. In particular, it returns a list with four
elements: <strong>iterations</strong>, which is a data frame with basic
characteristics of the calculated iteration index values (means,
standard deviations, coefficients of variation and results for all
sample), <strong>pseudovalues</strong>, which is a data frame with basic
characteristics of the calculated index pseudovalues obtained in the
jackknife procedure (i.e. the jackknife estimators and their standard
deviations and coefficients of variation),
<strong>figure_iterations</strong> which presents a box-plot for the
calculated iteration index values, and
<strong>figure_pseudovalues</strong> which presents a box-plot for the
calculated index pseudovalues obtained in the jackknife procedure.
Please follow the example, in which the Jevons, Fisher and GEKS indices
are compared by using the jackknife method:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="co">#creating a list with jackknife results</span></span>
<span id="cb70-2"><a href="#cb70-2" tabindex="-1"></a>comparison<span class="ot">&lt;-</span><span class="fu">compare_indices_jk</span>(milk,</span>
<span id="cb70-3"><a href="#cb70-3" tabindex="-1"></a><span class="at">formula=</span><span class="fu">c</span>(<span class="st">&quot;jevons&quot;</span>,<span class="st">&quot;fisher&quot;</span>,<span class="st">&quot;geks&quot;</span>),</span>
<span id="cb70-4"><a href="#cb70-4" tabindex="-1"></a><span class="at">start=</span><span class="st">&quot;2018-12&quot;</span>,</span>
<span id="cb70-5"><a href="#cb70-5" tabindex="-1"></a><span class="at">end=</span><span class="st">&quot;2019-12&quot;</span>, </span>
<span id="cb70-6"><a href="#cb70-6" tabindex="-1"></a><span class="at">window=</span><span class="fu">c</span>(<span class="dv">13</span>),</span>
<span id="cb70-7"><a href="#cb70-7" tabindex="-1"></a><span class="at">names=</span><span class="fu">c</span>(<span class="st">&quot;Jevons&quot;</span>,<span class="st">&quot;Fisher&quot;</span>,<span class="st">&quot;GEKS&quot;</span>), </span>
<span id="cb70-8"><a href="#cb70-8" tabindex="-1"></a><span class="at">by=</span><span class="st">&quot;retID&quot;</span>,</span>
<span id="cb70-9"><a href="#cb70-9" tabindex="-1"></a><span class="at">title_iterations=</span><span class="st">&quot;Box-plots for iteration values&quot;</span>,</span>
<span id="cb70-10"><a href="#cb70-10" tabindex="-1"></a><span class="at">title_pseudovalues=</span><span class="st">&quot;Box-plots for pseudovalues&quot;</span>)</span>
<span id="cb70-11"><a href="#cb70-11" tabindex="-1"></a><span class="co">#displaying a data frame with basic characteristics of the calculated iteration index values</span></span>
<span id="cb70-12"><a href="#cb70-12" tabindex="-1"></a>comparison<span class="sc">$</span>iterations</span></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a><span class="co">#displaying a data frame with basic characteristics of the calculated index pseudovalues obtained in the jackknife procedure</span></span>
<span id="cb71-2"><a href="#cb71-2" tabindex="-1"></a>comparison<span class="sc">$</span>pseudovalues</span></code></pre></div>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="co">#displaying box-plotes created for the calculated iteration index values</span></span>
<span id="cb72-2"><a href="#cb72-2" tabindex="-1"></a>comparison<span class="sc">$</span>figure_iterations</span></code></pre></div>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a><span class="co">#displaying box-plotes created for the calculated index pseudovalues obtained in the jackknife procedure</span></span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a>comparison<span class="sc">$</span>figure_pseudovalues</span></code></pre></div>
<p><a id="ad13"> </a></p>
</div>
<div id="functions-for-price-and-quantity-indicator-calculations" class="section level3">
<h3>Functions for price and quantity indicator calculations</h3>
<p>There are four package functions for calculating price and quantity
indicators. The <strong>bennet</strong> function returns the (bilateral)
Bennet price and quantity indicators and optionally also the price and
quantity contributions of individual products. The
<strong>mbennet</strong> function returns the multilateral (transitive)
Bennet price and quantity indicators and optionally also the price and
quantity contributions of individual products. The
<strong>montgomery</strong> function returns the (bilateral) Montgomery
price and quantity indicators and optionally also the price and quantity
contributions of individual products. The <strong>mmontgomery</strong>
function returns the multilateral (transitive) Montgomery price and
quantity indicators and optionally also the price and quantity
contributions of individual products.For instance, the following command
calculates the Bennet price and quantity indicators for milk
products:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="fu">bennet</span>(milk, <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>where price and quantity contributions of each subgroups of milk
products can be obtained as follows:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a>milk<span class="sc">$</span>prodID<span class="ot">&lt;-</span>milk<span class="sc">$</span>description</span>
<span id="cb75-2"><a href="#cb75-2" tabindex="-1"></a><span class="fu">bennet</span>(milk, <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>, <span class="at">contributions =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>The following command calculates the Montgomery price and quantity
indicators for coffee products:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a><span class="fu">montgomery</span>(coffee, <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>, <span class="at">interval=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>where price and quantity contributions of each subgroups of coffee
products can be obtained as follows:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a>coffee<span class="sc">$</span>prodID<span class="ot">&lt;-</span>coffee<span class="sc">$</span>description</span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a><span class="fu">montgomery</span>(coffee, <span class="at">start =</span> <span class="st">&quot;2018-12&quot;</span>, <span class="at">end =</span> <span class="st">&quot;2019-12&quot;</span>, <span class="at">contributions =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
